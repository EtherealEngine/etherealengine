
# Map Module

Responsible for the complete process of creating and updating map-based environments in the engine. That's "map" as in geography.

## High-level design

The process of fetching data from a `VectorTile` API and turning that data in to three.js meshes requires some intense CPU-bound work, the results of which need to be available to be used in the game, simulation etc ASAP while avoiding dropped frames. As such, this code makes use of caching to avoid re-work and workers threads to move CPU-bound work off of the main thread. To keep complexity under control, this code is organized in to "phases", a design pattern in which a complex process is broken down in to distinct types of tasks, with a unit of code called a "phase" responsible for enumerating and managing tasks of a particular type, while another unit of code decides which tasks to execute and when. The relationship between phases and tasks is similar to that of classes and class instances. For example, fetching `VectorTile` data from the API is a phase while fetching the data for a particular tile is a task within that phase. Tasks are identified by keys, which are composed of the minimum information necessary to execute the task. In the fetching example, the key would be the information needed to construct a URL for the tile being fetched. Tasks of one phases may depend on the data produced by another phase, in which case, the enumerated tasks of the dependant phase will only include the tasks which have the data they need. For example, a phase about converting `VectorTile`s to `GeoJSON` features will only include 1 task for each tile in the tile cache.

When the engine finds a [map node](packages/editor/src/nodes/MapNode.ts) while loading the world, it starts a set of phases that cascade results through a series of caches, the last of which is then iterated over by the [map update system](/packages/engine/src/map/MapUpdateSystem.ts) to populate the three.js scene. A center point, given as a lon/lat pair, combined with a radius, determines what data is fetched and eventually added to the scene, fetching tiles that overlap the circle, extracting features within those tiles the also overlap. When the center point changes the whole process defined by these phases is re-executed. Similarly, when local avatar moves more than a certain amount, the center point is updated and the process is re-executed. The caching architecture automatically ensures that work from previous executions can be reused as much as possible.
