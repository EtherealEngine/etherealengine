{
  "version": 3,
  "sources": ["../../../../node_modules/@feathersjs/authentication-client/src/storage.ts", "../../../../node_modules/@feathersjs/authentication-client/src/core.ts", "../../../../node_modules/@feathersjs/authentication-client/src/hooks/authentication.ts", "../../../../node_modules/@feathersjs/authentication-client/src/hooks/populate-header.ts", "../../../../node_modules/@feathersjs/authentication-client/src/hooks/index.ts", "../../../../node_modules/@feathersjs/authentication-client/src/index.ts"],
  "sourcesContent": ["export interface Storage {\n  getItem(key: string): any\n  setItem?(key: string, value: any): any\n  removeItem?(key: string): any\n}\n\nexport class MemoryStorage implements Storage {\n  store: { [key: string]: any }\n\n  constructor() {\n    this.store = {}\n  }\n\n  getItem(key: string) {\n    return Promise.resolve(this.store[key])\n  }\n\n  setItem(key: string, value: any) {\n    return Promise.resolve((this.store[key] = value))\n  }\n\n  removeItem(key: string) {\n    const value = this.store[key]\n\n    delete this.store[key]\n\n    return Promise.resolve(value)\n  }\n}\n\nexport class StorageWrapper implements Storage {\n  storage: any\n\n  constructor(storage: any) {\n    this.storage = storage\n  }\n\n  getItem(key: string) {\n    return Promise.resolve(this.storage.getItem(key))\n  }\n\n  setItem(key: string, value: any) {\n    return Promise.resolve(this.storage.setItem(key, value))\n  }\n\n  removeItem(key: string) {\n    return Promise.resolve(this.storage.removeItem(key))\n  }\n}\n", "import { NotAuthenticated, FeathersError } from '@feathersjs/errors'\nimport { Application, Params } from '@feathersjs/feathers'\nimport { AuthenticationRequest, AuthenticationResult } from '@feathersjs/authentication'\nimport { Storage, StorageWrapper } from './storage'\n\nclass OauthError extends FeathersError {\n  constructor(message: string, data?: any) {\n    super(message, 'OauthError', 401, 'oauth-error', data)\n  }\n}\n\nconst getMatch = (location: Location, key: string): [string, RegExp] => {\n  const regex = new RegExp(`(?:\\&?)${key}=([^&]*)`)\n  const match = location.hash ? location.hash.match(regex) : null\n\n  if (match !== null) {\n    const [, value] = match\n\n    return [value, regex]\n  }\n\n  return [null, regex]\n}\n\nexport type ClientConstructor = new (\n  app: Application,\n  options: AuthenticationClientOptions\n) => AuthenticationClient\n\nexport interface AuthenticationClientOptions {\n  storage: Storage\n  header: string\n  scheme: string\n  storageKey: string\n  locationKey: string\n  locationErrorKey: string\n  jwtStrategy: string\n  path: string\n  Authentication: ClientConstructor\n}\n\nexport class AuthenticationClient {\n  app: Application\n  authenticated: boolean\n  options: AuthenticationClientOptions\n\n  constructor(app: Application, options: AuthenticationClientOptions) {\n    const socket = app.io\n    const storage = new StorageWrapper(app.get('storage') || options.storage)\n\n    this.app = app\n    this.options = options\n    this.authenticated = false\n    this.app.set('storage', storage)\n\n    if (socket) {\n      this.handleSocket(socket)\n    }\n  }\n\n  get service() {\n    return this.app.service(this.options.path)\n  }\n\n  get storage() {\n    return this.app.get('storage') as Storage\n  }\n\n  handleSocket(socket: any) {\n    // When the socket disconnects and we are still authenticated, try to reauthenticate right away\n    // the websocket connection will handle timeouts and retries\n    socket.on('disconnect', () => {\n      if (this.authenticated) {\n        this.reAuthenticate(true)\n      }\n    })\n  }\n\n  /**\n   * Parse the access token or authentication error from the window location hash. Will remove it from the hash\n   * if found.\n   *\n   * @param location The window location\n   * @returns The access token if available, will throw an error if found, otherwise null\n   */\n  getFromLocation(location: Location) {\n    const [accessToken, tokenRegex] = getMatch(location, this.options.locationKey)\n\n    if (accessToken !== null) {\n      location.hash = location.hash.replace(tokenRegex, '')\n\n      return Promise.resolve(accessToken)\n    }\n\n    const [message, errorRegex] = getMatch(location, this.options.locationErrorKey)\n\n    if (message !== null) {\n      location.hash = location.hash.replace(errorRegex, '')\n\n      return Promise.reject(new OauthError(decodeURIComponent(message)))\n    }\n\n    return Promise.resolve(null)\n  }\n\n  /**\n   * Set the access token in storage.\n   *\n   * @param accessToken The access token to set\n   * @returns\n   */\n  setAccessToken(accessToken: string) {\n    return this.storage.setItem(this.options.storageKey, accessToken)\n  }\n\n  /**\n   * Returns the access token from storage or the window location hash.\n   *\n   * @returns The access token from storage or location hash\n   */\n  getAccessToken(): Promise<string | null> {\n    return this.storage.getItem(this.options.storageKey).then((accessToken: string) => {\n      if (!accessToken && typeof window !== 'undefined' && window.location) {\n        return this.getFromLocation(window.location)\n      }\n\n      return accessToken || null\n    })\n  }\n\n  /**\n   * Remove the access token from storage\n   * @returns The removed access token\n   */\n  removeAccessToken() {\n    return this.storage.removeItem(this.options.storageKey)\n  }\n\n  /**\n   * Reset the internal authentication state. Usually not necessary to call directly.\n   *\n   * @returns null\n   */\n  reset() {\n    this.app.set('authentication', null)\n    this.authenticated = false\n\n    return Promise.resolve(null)\n  }\n\n  handleError(error: FeathersError, type: 'authenticate' | 'logout') {\n    // For NotAuthenticated, PaymentError, Forbidden, NotFound, MethodNotAllowed, NotAcceptable\n    // errors, remove the access token\n    if (error.code > 400 && error.code < 408) {\n      const promise = this.removeAccessToken().then(() => this.reset())\n\n      return type === 'logout' ? promise : promise.then(() => Promise.reject(error))\n    }\n\n    return this.reset().then(() => Promise.reject(error))\n  }\n\n  /**\n   * Try to reauthenticate using the token from storage. Will do nothing if already authenticated unless\n   * `force` is true.\n   *\n   * @param force force reauthentication with the server\n   * @param strategy The name of the strategy to use. Defaults to `options.jwtStrategy`\n   * @returns The reauthentication result\n   */\n  reAuthenticate(force = false, strategy?: string): Promise<AuthenticationResult> {\n    // Either returns the authentication state or\n    // tries to re-authenticate with the stored JWT and strategy\n    let authPromise = this.app.get('authentication')\n\n    if (!authPromise || force === true) {\n      authPromise = this.getAccessToken().then((accessToken) => {\n        if (!accessToken) {\n          return this.handleError(new NotAuthenticated('No accessToken found in storage'), 'authenticate')\n        }\n\n        return this.authenticate({\n          strategy: strategy || this.options.jwtStrategy,\n          accessToken\n        })\n      })\n      this.app.set('authentication', authPromise)\n    }\n\n    return authPromise\n  }\n\n  /**\n   * Authenticate using a specific strategy and data.\n   *\n   * @param authentication The authentication data\n   * @param params Additional parameters\n   * @returns The authentication result\n   */\n  authenticate(authentication?: AuthenticationRequest, params?: Params): Promise<AuthenticationResult> {\n    if (!authentication) {\n      return this.reAuthenticate()\n    }\n\n    const promise = this.service\n      .create(authentication, params)\n      .then((authResult: AuthenticationResult) => {\n        const { accessToken } = authResult\n\n        this.authenticated = true\n        this.app.emit('login', authResult)\n        this.app.emit('authenticated', authResult)\n\n        return this.setAccessToken(accessToken).then(() => authResult)\n      })\n      .catch((error: FeathersError) => this.handleError(error, 'authenticate'))\n\n    this.app.set('authentication', promise)\n\n    return promise\n  }\n\n  /**\n   * Log out the current user and remove their token. Will do nothing\n   * if not authenticated.\n   *\n   * @returns The log out result.\n   */\n  logout(): Promise<AuthenticationResult | null> {\n    return Promise.resolve(this.app.get('authentication'))\n      .then(() =>\n        this.service.remove(null).then((authResult: AuthenticationResult) =>\n          this.removeAccessToken()\n            .then(() => this.reset())\n            .then(() => {\n              this.app.emit('logout', authResult)\n\n              return authResult\n            })\n        )\n      )\n      .catch((error: FeathersError) => this.handleError(error, 'logout'))\n  }\n}\n", "import { HookContext, NextFunction } from '@feathersjs/feathers'\nimport { stripSlashes } from '@feathersjs/commons'\n\nexport const authentication = () => {\n  return (context: HookContext, next: NextFunction) => {\n    const {\n      app,\n      params,\n      path,\n      method,\n      app: { authentication: service }\n    } = context\n\n    if (stripSlashes(service.options.path) === path && method === 'create') {\n      return next()\n    }\n\n    return Promise.resolve(app.get('authentication'))\n      .then((authResult) => {\n        if (authResult) {\n          context.params = Object.assign({}, authResult, params)\n        }\n      })\n      .then(next)\n  }\n}\n", "import { HookContext, NextFunction } from '@feathersjs/feathers'\n\nexport const populateHeader = () => {\n  return (context: HookContext, next: NextFunction) => {\n    const {\n      app,\n      params: { accessToken }\n    } = context\n    const authentication = app.authentication\n\n    // Set REST header if necessary\n    if (app.rest && accessToken) {\n      const { scheme, header } = authentication.options\n      const authHeader = `${scheme} ${accessToken}`\n\n      context.params.headers = Object.assign(\n        {},\n        {\n          [header]: authHeader\n        },\n        context.params.headers\n      )\n    }\n\n    return next()\n  }\n}\n", "export { authentication } from './authentication'\nexport { populateHeader } from './populate-header'\n", "import { AuthenticationClient, AuthenticationClientOptions } from './core'\nimport * as hooks from './hooks'\nimport { Application } from '@feathersjs/feathers'\nimport { Storage, MemoryStorage, StorageWrapper } from './storage'\n\ndeclare module '@feathersjs/feathers/lib/declarations' {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface Application<Services, Settings> {\n    // eslint-disable-line\n    io: any\n    rest?: any\n    authentication: AuthenticationClient\n    authenticate: AuthenticationClient['authenticate']\n    reAuthenticate: AuthenticationClient['reAuthenticate']\n    logout: AuthenticationClient['logout']\n  }\n}\n\nexport const getDefaultStorage = () => {\n  try {\n    return new StorageWrapper(window.localStorage)\n  } catch (error: any) {}\n\n  return new MemoryStorage()\n}\n\nexport { AuthenticationClient, AuthenticationClientOptions, Storage, MemoryStorage, hooks }\n\nexport type ClientConstructor = new (\n  app: Application,\n  options: AuthenticationClientOptions\n) => AuthenticationClient\n\nexport const defaultStorage: Storage = getDefaultStorage()\n\nexport const defaults: AuthenticationClientOptions = {\n  header: 'Authorization',\n  scheme: 'Bearer',\n  storageKey: 'feathers-jwt',\n  locationKey: 'access_token',\n  locationErrorKey: 'error',\n  jwtStrategy: 'jwt',\n  path: '/authentication',\n  Authentication: AuthenticationClient,\n  storage: defaultStorage\n}\n\nconst init = (_options: Partial<AuthenticationClientOptions> = {}) => {\n  const options: AuthenticationClientOptions = Object.assign({}, defaults, _options)\n  const { Authentication } = options\n\n  return (app: Application) => {\n    const authentication = new Authentication(app, options)\n\n    app.authentication = authentication\n    app.authenticate = authentication.authenticate.bind(authentication)\n    app.reAuthenticate = authentication.reAuthenticate.bind(authentication)\n    app.logout = authentication.logout.bind(authentication)\n\n    app.hooks([hooks.authentication(), hooks.populateHeader()])\n  }\n}\n\nexport default init\n\nif (typeof module !== 'undefined') {\n  module.exports = Object.assign(init, module.exports)\n}\n"],
  "mappings": "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",
  "names": []
}
