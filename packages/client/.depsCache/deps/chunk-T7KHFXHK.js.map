{
  "version": 3,
  "sources": ["../../../../node_modules/@reactflow/minimap/dist/esm/index.js"],
  "sourcesContent": ["import { jsx, jsxs } from 'react/jsx-runtime';\nimport { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { shallow } from 'zustand/shallow';\nimport { zoom, zoomIdentity } from 'd3-zoom';\nimport { select, pointer } from 'd3-selection';\nimport { useStoreApi, useStore, Panel, getNodePositionWithOrigin, getBoundsOfRects, getRectOfNodes } from '@reactflow/core';\n\nconst MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, }) => {\n    const { background, backgroundColor } = style || {};\n    const fill = (color || background || backgroundColor);\n    return (jsx(\"rect\", { className: cc(['react-flow__minimap-node', className]), x: x, y: y, rx: borderRadius, ry: borderRadius, width: width, height: height, fill: fill, stroke: strokeColor, strokeWidth: strokeWidth, shapeRendering: shapeRendering, onClick: onClick ? (event) => onClick(event, id) : undefined }));\n};\nMiniMapNode.displayName = 'MiniMapNode';\nvar MiniMapNode$1 = memo(MiniMapNode);\n\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector = (s) => {\n    const nodes = s.getNodes();\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2],\n    };\n    return {\n        nodes: nodes.filter((node) => !node.hidden && node.width && node.height),\n        viewBB,\n        boundingRect: nodes.length > 0 ? getBoundsOfRects(getRectOfNodes(nodes, s.nodeOrigin), viewBB) : viewBB,\n        rfId: s.rfId,\n        nodeOrigin: s.nodeOrigin,\n    };\n};\nconst getAttrFunction = (func) => (func instanceof Function ? func : () => func);\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMap({ style, className, nodeStrokeColor = 'transparent', nodeColor = '#e2e2e2', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, \n// We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly. \nnodeComponent: NodeComponent = MiniMapNode$1, maskColor = 'rgb(240, 240, 240, 0.6)', maskStrokeColor = 'none', maskStrokeWidth = 1, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', }) {\n    const store = useStoreApi();\n    const svg = useRef(null);\n    const { boundingRect, viewBB, nodes, rfId, nodeOrigin } = useStore(selector, shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = 5 * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = useRef(0);\n    viewScaleRef.current = viewScale;\n    useEffect(() => {\n        if (svg.current) {\n            const selection = select(svg.current);\n            const zoomHandler = (event) => {\n                const { transform, d3Selection, d3Zoom } = store.getState();\n                if (event.sourceEvent.type !== 'wheel' || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                const pinchDelta = -event.sourceEvent.deltaY *\n                    (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                    10;\n                const zoom = transform[2] * Math.pow(2, pinchDelta);\n                d3Zoom.scaleTo(d3Selection, zoom);\n            };\n            const panHandler = (event) => {\n                const { transform, d3Selection, d3Zoom, translateExtent, width, height } = store.getState();\n                if (event.sourceEvent.type !== 'mousemove' || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                // @TODO: how to calculate the correct next position? Math.max(1, transform[2]) is a workaround.\n                const position = {\n                    x: transform[0] - event.sourceEvent.movementX * viewScaleRef.current * Math.max(1, transform[2]),\n                    y: transform[1] - event.sourceEvent.movementY * viewScaleRef.current * Math.max(1, transform[2]),\n                };\n                const extent = [\n                    [0, 0],\n                    [width, height],\n                ];\n                const nextTransform = zoomIdentity.translate(position.x, position.y).scale(transform[2]);\n                const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);\n                d3Zoom.transform(d3Selection, constrainedTransform);\n            };\n            const zoomAndPanHandler = zoom()\n                // @ts-ignore\n                .on('zoom', pannable ? panHandler : null)\n                // @ts-ignore\n                .on('zoom.wheel', zoomable ? zoomHandler : null);\n            selection.call(zoomAndPanHandler);\n            return () => {\n                selection.on('zoom', null);\n            };\n        }\n    }, [pannable, zoomable]);\n    const onSvgClick = onClick\n        ? (event) => {\n            const rfCoord = pointer(event);\n            onClick(event, { x: rfCoord[0], y: rfCoord[1] });\n        }\n        : undefined;\n    const onSvgNodeClick = onNodeClick\n        ? (event, nodeId) => {\n            const node = store.getState().nodeInternals.get(nodeId);\n            onNodeClick(event, node);\n        }\n        : undefined;\n    return (jsx(Panel, { position: position, style: style, className: cc(['react-flow__minimap', className]), \"data-testid\": \"rf__minimap\", children: jsxs(\"svg\", { width: elementWidth, height: elementHeight, viewBox: `${x} ${y} ${width} ${height}`, role: \"img\", \"aria-labelledby\": labelledBy, ref: svg, onClick: onSvgClick, children: [ariaLabel && jsx(\"title\", { id: labelledBy, children: ariaLabel }), nodes.map((node) => {\n                    const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;\n                    return (jsx(NodeComponent, { x: x, y: y, width: node.width, height: node.height, style: node.style, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering: shapeRendering, onClick: onSvgNodeClick, id: node.id }, node.id));\n                }), jsx(\"path\", { className: \"react-flow__minimap-mask\", d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fill: maskColor, fillRule: \"evenodd\", stroke: maskStrokeColor, strokeWidth: maskStrokeWidth, pointerEvents: \"none\" })] }) }));\n}\nMiniMap.displayName = 'MiniMap';\nvar MiniMap$1 = memo(MiniMap);\n\nexport { MiniMap$1 as MiniMap };\n"],
  "mappings": "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",
  "names": ["width", "height", "position", "x", "y"]
}
