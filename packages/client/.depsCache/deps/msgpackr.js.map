{
  "version": 3,
  "sources": ["../../../../node_modules/msgpackr/unpack.js", "../../../../node_modules/msgpackr/pack.js", "../../../../node_modules/msgpackr/iterators.js", "../../../../node_modules/msgpackr/index.js"],
  "sourcesContent": ["var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, end) {\n\t\treturn this.unpack(source, end)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + JSON.stringify(result).slice(0, 100))\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (globalThis[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new globalThis[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n", "import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\tif (structures.length > sharedLength)\n\t\t\t\t\t\tstructures.length = sharedLength\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tstructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t}\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\treturn packr.pack(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else if (type === 'function') {\n\t\t\t\tpack(this.writeFunction && this.writeFunction()) // if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(key = keys[i])\n\t\t\t\tpack(object[key])\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tpack(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\n", "import { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nexport const decodeIter = unpackIter\nexport const encodeIter = packIter", "export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\n"],
  "mappings": "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",
  "names": ["readObject", "target", "position", "bundledStrings", "referenceMap", "pack", "maxBytes", "key", "newPosition", "pack", "target", "targetView", "position", "encode", "bundledStrings", "addExtension"]
}
