{
  "version": 3,
  "sources": ["../../../../node_modules/ts-matches/esm/src/parsers/utils.js", "../../../../node_modules/ts-matches/esm/src/parsers/guard-parser.js", "../../../../node_modules/ts-matches/esm/src/utils.js", "../../../../node_modules/ts-matches/esm/src/parsers/any-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/array-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/bool-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/concat-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/default-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/function-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/mapped-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/maybe-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/named.js", "../../../../node_modules/ts-matches/esm/src/parsers/nill-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/number-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/object-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/or-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/shape-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/string-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/unknown-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/simple-parsers.js", "../../../../node_modules/ts-matches/esm/src/parsers/some-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/every-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/dictionary-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/tuple-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/array-of-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/literal-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/recursive-parser.js", "../../../../node_modules/ts-matches/esm/src/parsers/deferred-parser.js", "../../../../node_modules/ts-matches/esm/src/matches.js", "../../../../node_modules/ts-matches/esm/mod.js"],
  "sourcesContent": ["export const isObject = (x) => typeof x === \"object\" && x != null;\nexport const isFunctionTest = (x) => typeof x === \"function\";\nexport const isNumber = (x) => typeof x === \"number\";\nexport const isString = (x) => typeof x === \"string\";\nexport const empty = [];\nexport const booleanOnParse = {\n    parsed(_) {\n        return true;\n    },\n    invalid(_) {\n        return false;\n    },\n};\n", "export class GuardParser {\n    constructor(checkIsA, typeName, description = {\n        name: \"Guard\",\n        children: [],\n        extras: [typeName],\n    }) {\n        Object.defineProperty(this, \"checkIsA\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: checkIsA\n        });\n        Object.defineProperty(this, \"typeName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: typeName\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (this.checkIsA(a)) {\n            return onParse.parsed(a);\n        }\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "/**\n * Tries and run the stringify, if that fails just return the toString\n * @param x Could be anything, including a recursive object\n */\nexport function saferStringify(x) {\n    try {\n        return JSON.stringify(x);\n    }\n    catch (e) {\n        return \"\" + x;\n    }\n}\n", "export class AnyParser {\n    constructor(description = {\n        name: \"Any\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        return onParse.parsed(a);\n    }\n}\n", "export class ArrayParser {\n    constructor(description = {\n        name: \"Array\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (Array.isArray(a))\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "export class BoolParser {\n    constructor(description = {\n        name: \"Boolean\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (a === true || a === false)\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "export class ConcatParsers {\n    constructor(parent, otherParser, description = {\n        name: \"Concat\",\n        children: [parent, otherParser],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"otherParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: otherParser\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    static of(parent, otherParser) {\n        if (parent.unwrappedParser().description.name === \"Any\") {\n            return otherParser;\n        }\n        if (otherParser.unwrappedParser().description.name === \"Any\") {\n            return parent;\n        }\n        return new ConcatParsers(parent, otherParser);\n    }\n    parse(a, onParse) {\n        const parent = this.parent.enumParsed(a);\n        if (\"error\" in parent) {\n            return onParse.invalid(parent.error);\n        }\n        const other = this.otherParser.enumParsed(parent.value);\n        if (\"error\" in other) {\n            return onParse.invalid(other.error);\n        }\n        return onParse.parsed(other.value);\n    }\n}\n", "export class DefaultParser {\n    constructor(parent, defaultValue, description = {\n        name: \"Default\",\n        children: [parent],\n        extras: [defaultValue],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"defaultValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: defaultValue\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        const defaultValue = this.defaultValue;\n        if (a == null) {\n            return onParse.parsed(defaultValue);\n        }\n        const parentCheck = this.parent.enumParsed(a);\n        if (\"error\" in parentCheck) {\n            parentCheck.error.parser = parser;\n            return onParse.invalid(parentCheck.error);\n        }\n        return onParse.parsed(parentCheck.value);\n    }\n}\n", "import { isFunctionTest } from \"./utils.js\";\nexport class FunctionParser {\n    constructor(description = {\n        name: \"Function\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (isFunctionTest(a))\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "export class MappedAParser {\n    constructor(parent, map, mappingName = map.name, description = {\n        name: \"Mapped\",\n        children: [parent],\n        extras: [mappingName],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"map\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: map\n        });\n        Object.defineProperty(this, \"mappingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: mappingName\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        const map = this.map;\n        const result = this.parent.enumParsed(a);\n        if (\"error\" in result) {\n            return onParse.invalid(result.error);\n        }\n        return onParse.parsed(map(result.value));\n    }\n}\n", "export class MaybeParser {\n    constructor(parent, description = {\n        name: \"Maybe\",\n        children: [parent],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (a == null) {\n            return onParse.parsed(null);\n        }\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        const parentState = this.parent.enumParsed(a);\n        if (\"error\" in parentState) {\n            const { error } = parentState;\n            error.parser = parser;\n            return onParse.invalid(error);\n        }\n        return onParse.parsed(parentState.value);\n    }\n}\n", "import { Parser } from \"./index.js\";\nexport class NamedParser {\n    constructor(parent, name, description = {\n        name: \"Named\",\n        children: [parent],\n        extras: [name],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        const parent = this.parent.enumParsed(a);\n        if (\"error\" in parent) {\n            const { error } = parent;\n            error.parser = parser;\n            return onParse.invalid(error);\n        }\n        return onParse.parsed(parent.value);\n    }\n}\nexport function parserName(name, parent) {\n    return new Parser(new NamedParser(parent, name));\n}\n", "export class NilParser {\n    constructor(description = {\n        name: \"Null\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (a === null || a === undefined)\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "import { isNumber } from \"./index.js\";\nexport class NumberParser {\n    constructor(description = {\n        name: \"Number\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (isNumber(a))\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "import { isObject } from \"./utils.js\";\nexport class ObjectParser {\n    constructor(description = {\n        name: \"Object\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (isObject(a))\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "export class OrParsers {\n    constructor(parent, otherParser, description = {\n        name: \"Or\",\n        children: [parent, otherParser],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parent\n        });\n        Object.defineProperty(this, \"otherParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: otherParser\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        const parent = this.parent.enumParsed(a);\n        if (\"value\" in parent) {\n            return onParse.parsed(parent.value);\n        }\n        const other = this.otherParser.enumParsed(a);\n        if (\"error\" in other) {\n            const { error } = other;\n            error.parser = parser;\n            return onParse.invalid(error);\n        }\n        return onParse.parsed(other.value);\n    }\n}\n", "// deno-lint-ignore-file no-explicit-any ban-types\nimport { every, object, Parser } from \"./index.js\";\nimport { saferStringify } from \"../utils.js\";\n/**\n * Given an object, we want to make sure the key exists and that the value on\n * the key matches the parser\n */\nexport class ShapeParser {\n    constructor(parserMap, isPartial, parserKeys = Object.keys(parserMap), description = {\n        name: isPartial ? \"Partial\" : \"Shape\",\n        children: parserKeys.map((key) => parserMap[key]),\n        extras: parserKeys,\n    }) {\n        Object.defineProperty(this, \"parserMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parserMap\n        });\n        Object.defineProperty(this, \"isPartial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: isPartial\n        });\n        Object.defineProperty(this, \"parserKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parserKeys\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        if (!object.test(a)) {\n            return onParse.invalid({\n                value: a,\n                keys: [],\n                parser,\n            });\n        }\n        const { parserMap, isPartial } = this;\n        const value = { ...a };\n        if (Array.isArray(a)) {\n            value.length = a.length;\n        }\n        for (const key in parserMap) {\n            if (key in value) {\n                const parser = parserMap[key];\n                const state = parser.enumParsed(a[key]);\n                if (\"error\" in state) {\n                    const { error } = state;\n                    error.keys.push(saferStringify(key));\n                    return onParse.invalid(error);\n                }\n                const smallValue = state.value;\n                value[key] = smallValue;\n            }\n            else if (!isPartial) {\n                return onParse.invalid({\n                    value: \"missingProperty\",\n                    parser,\n                    keys: [saferStringify(key)],\n                });\n            }\n        }\n        return onParse.parsed(value);\n    }\n}\nexport const isPartial = (testShape) => {\n    return new Parser(new ShapeParser(testShape, true));\n};\n/**\n * Good for duck typing an object, with optional values\n * @param testShape Shape of validators, to ensure we match the shape\n */\nexport const partial = isPartial;\n/**\n * Good for duck typing an object\n * @param testShape Shape of validators, to ensure we match the shape\n */\nexport const isShape = (testShape) => {\n    return new Parser(new ShapeParser(testShape, false));\n};\nexport function shape(testShape, optionals, optionalAndDefaults) {\n    if (optionals) {\n        const defaults = optionalAndDefaults || {};\n        const entries = Object.entries(testShape);\n        const optionalSet = new Set(Array.from(optionals));\n        return every(partial(Object.fromEntries(entries\n            .filter(([key, _]) => optionalSet.has(key))\n            .map(([key, parser]) => [key, parser.optional()]))), isShape(Object.fromEntries(entries.filter(([key, _]) => !optionalSet.has(key))))).map((ret) => {\n            for (const key of optionalSet) {\n                const keyAny = key;\n                if (!(keyAny in ret) && keyAny in defaults) {\n                    ret[keyAny] = defaults[keyAny];\n                }\n            }\n            return ret;\n        });\n    }\n    return isShape(testShape);\n}\n", "import { isString } from \"./utils.js\";\nexport class StringParser {\n    constructor(description = {\n        name: \"String\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (isString(a))\n            return onParse.parsed(a);\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\n", "import { IsAParser } from \"./index.js\";\nimport { saferStringify } from \"../utils.js\";\nimport { AnyParser } from \"./any-parser.js\";\nimport { ArrayParser } from \"./array-parser.js\";\nimport { BoolParser } from \"./bool-parser.js\";\nimport { ConcatParsers } from \"./concat-parser.js\";\nimport { DefaultParser } from \"./default-parser.js\";\nimport { FunctionParser } from \"./function-parser.js\";\nimport { GuardParser } from \"./guard-parser.js\";\nimport { MappedAParser } from \"./mapped-parser.js\";\nimport { MaybeParser } from \"./maybe-parser.js\";\nimport { parserName } from \"./named.js\";\nimport { NilParser } from \"./nill-parser.js\";\nimport { NumberParser } from \"./number-parser.js\";\nimport { ObjectParser } from \"./object-parser.js\";\nimport { OrParsers } from \"./or-parser.js\";\nimport { ShapeParser } from \"./shape-parser.js\";\nimport { StringParser } from \"./string-parser.js\";\nimport { booleanOnParse } from \"./utils.js\";\nfunction unwrapParser(a) {\n    if (a instanceof Parser)\n        return unwrapParser(a.parser);\n    return a;\n}\nconst enumParsed = {\n    parsed(value) {\n        return { value };\n    },\n    invalid(error) {\n        return { error };\n    },\n};\n/**\n * A Parser is usually a function that takes a value and returns a Parsed value.\n * For this class we have that as our main reason but we want to be able to have other methods\n * including testing and showing text representations.\n *\n * The main function unsafeCast which will take in a value A (usually unknown) and will always return a B. If it cannot\n * it will throw an error.\n *\n * The parse function is the lower level function that will take in a value and a dictionary of what to do with success and failure.\n */\nexport class Parser {\n    constructor(parser, description = {\n        name: \"Wrapper\",\n        children: [parser],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parser\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n        /// This is a hack to get the type of what the parser is going to return.\n        // deno-lint-ignore no-explicit-any\n        Object.defineProperty(this, \"_TYPE\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        /**\n         * Use this as a guard clause, useful for escaping during the error cases.\n         * https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\n         * @param value\n         * @returns\n         */\n        Object.defineProperty(this, \"test\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (value) => {\n                return this.parse(value, booleanOnParse);\n            }\n        });\n    }\n    /**\n     * Use this when you want to decide what happens on the succes and failure cases of parsing\n     * @param a\n     * @param onParse\n     * @returns\n     */\n    parse(a, onParse) {\n        return this.parser.parse(a, onParse);\n    }\n    /**\n     * This is a constructor helper that can use a predicate tester in the form of a guard function,\n     * and will return a parser that will only parse if the predicate returns true.\n     * https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\n     * @param checkIsA\n     * @param name\n     * @returns\n     */\n    static isA(checkIsA, name) {\n        return new Parser(new IsAParser(checkIsA, name));\n    }\n    /**\n     * Trying to convert the parser into a string representation\n     * @param parserComingIn\n     * @returns\n     */\n    static parserAsString(parserComingIn) {\n        const parser = unwrapParser(parserComingIn);\n        const { description: { name, extras, children }, } = parser;\n        if (parser instanceof ShapeParser) {\n            return `${name}<{${parser.description.children\n                .map((subParser, i) => `${String(parser.description.extras[i]) || \"?\"}:${Parser.parserAsString(subParser)}`)\n                .join(\",\")}}>`;\n        }\n        if (parser instanceof OrParsers) {\n            const parent = unwrapParser(parser.parent);\n            const parentString = Parser.parserAsString(parent);\n            if (parent instanceof OrParsers)\n                return parentString;\n            return `${name}<${parentString},...>`;\n        }\n        if (parser instanceof GuardParser) {\n            return String(extras[0] || name);\n        }\n        if (parser instanceof StringParser ||\n            parser instanceof ObjectParser ||\n            parser instanceof NumberParser ||\n            parser instanceof BoolParser ||\n            parser instanceof AnyParser) {\n            return name.toLowerCase();\n        }\n        if (parser instanceof FunctionParser) {\n            return name;\n        }\n        if (parser instanceof NilParser) {\n            return \"null\";\n        }\n        if (parser instanceof ArrayParser) {\n            return \"Array<unknown>\";\n        }\n        const specifiers = [\n            ...extras.map(saferStringify),\n            ...children.map(Parser.parserAsString),\n        ];\n        const specifiersString = `<${specifiers.join(\",\")}>`;\n        return `${name}${specifiersString}`;\n    }\n    /**\n     * This is the most useful parser, it assumes the happy path and will throw an error if it fails.\n     * @param value\n     * @returns\n     */\n    unsafeCast(value) {\n        const state = this.enumParsed(value);\n        if (\"value\" in state)\n            return state.value;\n        const { error } = state;\n        throw new TypeError(`Failed type: ${Parser.validatorErrorAsString(error)} given input ${saferStringify(value)}`);\n    }\n    /**\n     * This is the like the unsafe parser, it assumes the happy path and will throw and return a failed promise during failure.\n     * @param value\n     * @returns\n     */\n    castPromise(value) {\n        const state = this.enumParsed(value);\n        if (\"value\" in state)\n            return Promise.resolve(state.value);\n        const { error } = state;\n        return Promise.reject(new TypeError(`Failed type: ${Parser.validatorErrorAsString(error)} given input ${saferStringify(value)}`));\n    }\n    /**\n     * When we want to get the error message from the input, to know what is wrong\n     * @param input\n     * @returns Null if there is no error\n     */\n    errorMessage(input) {\n        const parsed = this.parse(input, enumParsed);\n        if (\"value\" in parsed)\n            return;\n        return Parser.validatorErrorAsString(parsed.error);\n    }\n    /**\n     * Use this that we want to do transformations after the value is valid and parsed.\n     * A use case would be parsing a string, making sure it can be parsed to a number, and then convert to a number\n     * @param fn\n     * @param mappingName\n     * @returns\n     */\n    map(fn, mappingName) {\n        return new Parser(new MappedAParser(this, fn, mappingName));\n    }\n    /**\n     * Use this when you want to combine two parsers into one. This will make sure that both parsers will run against the same value.\n     * @param otherParser\n     * @returns\n     */\n    concat(otherParser) {\n        // deno-lint-ignore no-explicit-any\n        return new Parser(ConcatParsers.of(this, new Parser(otherParser)));\n    }\n    /**\n     * Use this to combine parsers into one. This will make sure that one or the other parsers will run against the value.\n     * @param otherParser\n     * @returns\n     */\n    orParser(otherParser) {\n        return new Parser(new OrParsers(this, new Parser(otherParser)));\n    }\n    /**\n     * When we want to make sure that we handle the null later on in a monoid fashion,\n     * and this ensures we deal with the value\n     * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining\n     */\n    optional(_name) {\n        return new Parser(new MaybeParser(this));\n    }\n    /**\n     * There are times that we would like to bring in a value that we know as null or undefined\n     * and want it to go to a default value\n     */\n    defaultTo(defaultValue) {\n        return new Parser(new DefaultParser(new Parser(new MaybeParser(this)), defaultValue));\n    }\n    /**\n     * We want to test value with a test eg isEven\n     */\n    validate(isValid, otherName) {\n        return new Parser(ConcatParsers.of(this, new Parser(new IsAParser(isValid, otherName))));\n    }\n    /**\n     * We want to refine to a new type given an original type, like isEven, or casting to a more\n     * specific type\n     */\n    refine(refinementTest, otherName = refinementTest.name) {\n        return new Parser(ConcatParsers.of(this, new Parser(new IsAParser(refinementTest, otherName))));\n    }\n    /**\n     * Use this when we want to give the parser a name, and we want to be able to use the name in the error messages.\n     * @param nameString\n     * @returns\n     */\n    name(nameString) {\n        return parserName(nameString, this);\n    }\n    /**\n     * This is another type of parsing that will return a value that is a discriminated union of the success and failure cases.\n     * https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions\n     * @param value\n     * @returns\n     */\n    enumParsed(value) {\n        // deno-lint-ignore no-explicit-any\n        return this.parse(value, enumParsed);\n    }\n    /**\n     * Return the unwrapped parser/ IParser\n     * @returns\n     */\n    unwrappedParser() {\n        // deno-lint-ignore no-this-alias no-explicit-any\n        let answer = this;\n        while (true) {\n            const next = answer.parser;\n            if (next instanceof Parser) {\n                answer = next;\n            }\n            else {\n                return next;\n            }\n        }\n    }\n}\n/**\n * This is the line of code that could be over written if\n * One would like to have a custom error as any shape\n */\nObject.defineProperty(Parser, \"validatorErrorAsString\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: (error) => {\n        const { parser, value, keys } = error;\n        const keysString = !keys.length ? \"\" : keys\n            .map((x) => `[${x}]`)\n            .reverse()\n            .join(\"\");\n        return `${keysString}${Parser.parserAsString(parser)}(${saferStringify(value)})`;\n    }\n});\n", "export class UnknownParser {\n    constructor(description = {\n        name: \"Unknown\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        return onParse.parsed(a);\n    }\n}\n", "import { Parser } from \"./index.js\";\nimport { AnyParser } from \"./any-parser.js\";\nimport { ArrayParser } from \"./array-parser.js\";\nimport { BoolParser } from \"./bool-parser.js\";\nimport { FunctionParser } from \"./function-parser.js\";\nimport { NilParser } from \"./nill-parser.js\";\nimport { NumberParser } from \"./number-parser.js\";\nimport { ObjectParser } from \"./object-parser.js\";\nimport { StringParser } from \"./string-parser.js\";\nimport { UnknownParser } from \"./unknown-parser.js\";\n/**\n * Create a custom type guard\n * @param test A function that will determine runtime if the value matches\n * @param testName A name for that function, useful when it fails\n */\nexport function guard(test, testName) {\n    return Parser.isA(test, testName || test.name);\n}\nexport const any = new Parser(new AnyParser());\nexport const unknown = new Parser(new UnknownParser());\nexport const number = new Parser(new NumberParser());\nexport const isNill = new Parser(new NilParser());\nexport const natural = number.refine((x) => x >= 0 && x === Math.floor(x));\nexport const isFunction = new Parser(new FunctionParser());\nexport const boolean = new Parser(new BoolParser());\nexport const object = new Parser(new ObjectParser());\nexport const isArray = new Parser(new ArrayParser());\nexport const string = new Parser(new StringParser());\nexport const instanceOf = (classCreator) => guard((x) => x instanceof classCreator, `is${classCreator.name}`);\nexport const regex = (tester) => string.refine(function (x) {\n    return tester.test(x);\n}, tester.toString());\n", "import { any } from \"./simple-parsers.js\";\n/**\n * Union is a good tool to make sure that the validated value\n * is in the union of all the validators passed in. Basically an `or`\n * operator for validators.\n */\nexport function some(...parsers) {\n    if (parsers.length <= 0) {\n        return any;\n    }\n    const first = parsers.splice(0, 1)[0];\n    return parsers.reduce((left, right) => left.orParser(right), first);\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { any } from \"./index.js\";\n/**\n * Intersection is a good tool to make sure that the validated value\n * is in the intersection of all the validators passed in. Basically an `and`\n * operator for validators\n */\nexport function every(...parsers) {\n    const filteredParsers = parsers.filter((x) => x !== any);\n    if (filteredParsers.length <= 0) {\n        return any;\n    }\n    const first = filteredParsers.splice(0, 1)[0];\n    return filteredParsers.reduce((left, right) => {\n        return left.concat(right);\n    }, first);\n}\n", "// deno-lint-ignore-file no-explicit-any ban-types\nimport { object } from \"./index.js\";\nexport class DictionaryParser {\n    constructor(parsers, description = {\n        name: \"Dictionary\",\n        children: parsers.reduce((acc, [k, v]) => {\n            acc.push(k, v);\n            return acc;\n        }, []),\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parsers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parsers\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        const { parsers } = this;\n        // deno-lint-ignore no-this-alias\n        const parser = this;\n        const entries = Object.entries(a);\n        for (const entry of entries) {\n            const [key, value] = entry;\n            const found = findOrError(parsers, key, value, parser);\n            if (found == undefined)\n                return onParse.parsed(a);\n            if (\"error\" in found)\n                return onParse.invalid(found.error);\n            entry[0] = found[0].value;\n            entry[1] = found[1].value;\n        }\n        const answer = Object.fromEntries(entries);\n        return onParse.parsed(answer);\n    }\n}\nexport const dictionary = (...parsers) => {\n    return object.concat(new DictionaryParser([...parsers]));\n};\nfunction findOrError(parsers, key, value, parser) {\n    let foundError;\n    for (const [keyParser, valueParser] of parsers) {\n        const enumState = keyParser.enumParsed(key);\n        const valueState = valueParser.enumParsed(value);\n        if (\"error\" in enumState) {\n            if (!foundError) {\n                const { error } = enumState;\n                error.parser = parser;\n                error.keys.push(\"\" + key);\n                foundError = { error };\n            }\n            continue;\n        }\n        const newKey = enumState.value;\n        if (\"error\" in valueState) {\n            if (!foundError) {\n                const { error } = valueState;\n                error.keys.push(\"\" + newKey);\n                foundError = { error };\n            }\n            continue;\n        }\n        return [enumState, valueState];\n    }\n    return foundError;\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { isArray, literal, Parser } from \"./index.js\";\nimport { saferStringify } from \"../utils.js\";\nexport class TupleParser {\n    constructor(parsers, lengthMatcher = literal(parsers.length), description = {\n        name: \"Tuple\",\n        children: parsers,\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parsers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parsers\n        });\n        Object.defineProperty(this, \"lengthMatcher\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: lengthMatcher\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(input, onParse) {\n        const tupleError = isArray.enumParsed(input);\n        if (\"error\" in tupleError)\n            return onParse.invalid(tupleError.error);\n        const values = input;\n        const stateCheck = this.lengthMatcher.enumParsed(values.length);\n        if (\"error\" in stateCheck) {\n            stateCheck.error.keys.push(saferStringify(\"length\"));\n            return onParse.invalid(stateCheck.error);\n        }\n        const answer = new Array(this.parsers.length);\n        for (const key in this.parsers) {\n            const parser = this.parsers[key];\n            const value = values[key];\n            const result = parser.enumParsed(value);\n            if (\"error\" in result) {\n                const { error } = result;\n                error.keys.push(saferStringify(key));\n                return onParse.invalid(error);\n            }\n            answer[key] = result.value;\n        }\n        return onParse.parsed(answer);\n    }\n}\nexport function tuple(...parsers) {\n    return new Parser(new TupleParser(parsers));\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { Parser } from \"./index.js\";\n/**\n * Given an object, we want to make sure the key exists and that the value on\n * the key matches the parser\n * Note: This will mutate the value sent through\n */\nexport class ArrayOfParser {\n    constructor(parser, description = {\n        name: \"ArrayOf\",\n        children: [parser],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"parser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: parser\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (!Array.isArray(a)) {\n            return onParse.invalid({\n                value: a,\n                keys: [],\n                parser: this,\n            });\n        }\n        const values = [...a];\n        for (let index = 0; index < values.length; index++) {\n            const result = this.parser.enumParsed(values[index]);\n            if (\"error\" in result) {\n                result.error.keys.push(\"\" + index);\n                return onParse.invalid(result.error);\n            }\n            else {\n                values[index] = result.value;\n            }\n        }\n        return onParse.parsed(values);\n    }\n}\n/**\n * We would like to validate that all of the array is of the same type\n * @param validator What is the validator for the values in the array\n */\nexport function arrayOf(validator) {\n    return new Parser(new ArrayOfParser(validator));\n}\n", "import { Parser } from \"./parser.js\";\nexport class LiteralsParser {\n    constructor(values, description = {\n        name: \"Literal\",\n        children: [],\n        extras: values,\n    }) {\n        Object.defineProperty(this, \"values\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: values\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n    }\n    parse(a, onParse) {\n        if (this.values.indexOf(a) >= 0) {\n            return onParse.parsed(a);\n        }\n        return onParse.invalid({\n            value: a,\n            keys: [],\n            parser: this,\n        });\n    }\n}\nexport function literal(isEqualToValue) {\n    return new Parser(new LiteralsParser([isEqualToValue]));\n}\nexport function literals(firstValue, ...restValues) {\n    return new Parser(new LiteralsParser([firstValue, ...restValues]));\n}\n", "import { Parser } from \"./parser.js\";\nimport { any } from \"./simple-parsers.js\";\n/**\n * This parser is used when trying to create parsers that\n * user their own definitions in their types, like interface Tree<Leaf> {\n *   [key: string]: Tree<Leaf> | Leaf;\n * }\n */\nexport class RecursiveParser {\n    constructor(recursive, description = {\n        name: \"Recursive\",\n        children: [],\n        extras: [recursive],\n    }) {\n        Object.defineProperty(this, \"recursive\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: recursive\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n        Object.defineProperty(this, \"parser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    static create(fn) {\n        const parser = new RecursiveParser(fn);\n        parser.parser = fn(new Parser(parser));\n        return parser;\n    }\n    parse(a, onParse) {\n        if (!this.parser) {\n            return onParse.invalid({\n                value: \"Recursive Invalid State\",\n                keys: [],\n                parser: this,\n            });\n        }\n        return this.parser.parse(a, onParse);\n    }\n}\n/**\n * Must pass the shape that we expect since typescript as of this point\n * can't infer with recursive functions like this.\n * @param fn This should be a function that takes a parser, basically the self in a type recursion, and\n * return a parser that is the combination of the recursion.\n * @returns\n */\nexport function recursive(fn) {\n    const value = fn(any);\n    const created = RecursiveParser\n        .create(fn);\n    return new Parser(created);\n}\n", "import { Parser } from \"./parser.js\";\n/**\n * This is needed when the typescript has a recursive, mutual types\n * type Things = string | [OtherThings]\n * type OtherThings = {type: 'other', value:Things }\n */\nexport class DeferredParser {\n    constructor(description = {\n        name: \"Deferred\",\n        children: [],\n        extras: [],\n    }) {\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: description\n        });\n        Object.defineProperty(this, \"parser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    static create() {\n        return new DeferredParser();\n    }\n    setParser(parser) {\n        this.parser = new Parser(parser);\n        return this;\n    }\n    parse(a, onParse) {\n        if (!this.parser) {\n            return onParse.invalid({\n                value: \"Not Set Up\",\n                keys: [],\n                parser: this,\n            });\n        }\n        return this.parser.parse(a, onParse);\n    }\n}\n/**\n * Must pass the shape that we expect since typescript as of this point\n * can't infer with recursive like structures like this.\n * @returns [Parser, setParser] Use the setParser to set the parser later\n */\nexport function deferred() {\n    const deferred = DeferredParser.create();\n    function setParser(parser) {\n        deferred.setParser(parser);\n    }\n    return [new Parser(deferred), setParser];\n}\n", "import { any, arrayOf, boolean, deferred, dictionary, every, guard, instanceOf, isArray, isFunction, isNill, literal, literals, natural, number, object, Parser, partial, recursive, regex, shape, some, string, tuple, } from \"./parsers/index.js\";\nimport { parserName } from \"./parsers/named.js\";\nimport { unknown } from \"./parsers/simple-parsers.js\";\nexport { Parser as Validator };\nclass Matched {\n    constructor(value) {\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n        });\n        Object.defineProperty(this, \"when\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ((..._args) => {\n                // deno-lint-ignore no-explicit-any\n                return this;\n                // deno-lint-ignore no-explicit-any\n            })\n        });\n        Object.defineProperty(this, \"unwrap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (() => {\n                return this.value;\n                // deno-lint-ignore no-explicit-any\n            })\n        });\n    }\n    defaultTo(_defaultValue) {\n        return this.value;\n    }\n    defaultToLazy(_getValue) {\n        return this.value;\n    }\n}\nclass MatchMore {\n    constructor(a) {\n        Object.defineProperty(this, \"a\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: a\n        });\n        Object.defineProperty(this, \"when\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ((...args) => {\n                const [outcome, ...matchers] = args.reverse();\n                // deno-lint-ignore no-this-alias\n                const me = this;\n                const parser = matches.some(...matchers.map((matcher) => \n                // deno-lint-ignore no-explicit-any\n                matcher instanceof Parser ? matcher : literal(matcher)));\n                const result = parser.enumParsed(this.a);\n                if (\"error\" in result) {\n                    // deno-lint-ignore no-explicit-any\n                    return me;\n                }\n                const { value } = result;\n                if (outcome instanceof Function) {\n                    // deno-lint-ignore no-explicit-any\n                    return new Matched(outcome(value));\n                }\n                // deno-lint-ignore no-explicit-any\n                return new Matched(outcome);\n                // deno-lint-ignore no-explicit-any\n            })\n        });\n        Object.defineProperty(this, \"unwrap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (() => {\n                throw new Error(\"Expecting that value is matched\");\n                // deno-lint-ignore no-explicit-any\n            })\n        });\n    }\n    defaultTo(value) {\n        return value;\n    }\n    defaultToLazy(getValue) {\n        return getValue();\n    }\n}\n/**\n * Want to be able to bring in the declarative nature that a functional programming\n * language feature of the pattern matching and the switch statement. With the destructors\n * the only thing left was to find the correct structure then move move forward.\n * Using a structure in chainable fashion allows for a syntax that works with typescript\n * while looking similar to matches statements in other languages\n *\n * Use: matches('a value').when(matches.isNumber, (aNumber) => aNumber + 4).defaultTo('fallback value')\n */\nexport const matches = Object.assign(function matchesFn(value) {\n    return new MatchMore(value);\n}, {\n    array: isArray,\n    arrayOf,\n    some,\n    tuple,\n    regex,\n    number,\n    natural,\n    isFunction,\n    object,\n    string,\n    shape,\n    partial,\n    literal,\n    every,\n    guard,\n    unknown,\n    any,\n    boolean,\n    dictionary,\n    literals,\n    nill: isNill,\n    instanceOf,\n    Parse: Parser,\n    parserName,\n    recursive,\n    deferred,\n});\nconst array = isArray;\nconst nill = isNill;\nconst Parse = Parser;\nconst oneOf = some;\nconst anyOf = some;\nconst allOf = every;\nexport { allOf, any, anyOf, array, arrayOf, boolean, deferred, dictionary, every, guard, instanceOf, isFunction, literal, literals, natural, nill, number, object, oneOf, Parse, Parser, parserName, partial, recursive, regex, shape, some, string, tuple, unknown, };\nexport default matches;\n", "export * from \"./src/matches.js\";\nimport matches from \"./src/matches.js\";\nexport { AnyParser } from \"./src/parsers/any-parser.js\";\nexport { ArrayParser } from \"./src/parsers/array-parser.js\";\nexport { BoolParser } from \"./src/parsers/bool-parser.js\";\nexport { FunctionParser } from \"./src/parsers/function-parser.js\";\nexport { GuardParser } from \"./src/parsers/guard-parser.js\";\nexport { NilParser } from \"./src/parsers/nill-parser.js\";\nexport { NumberParser } from \"./src/parsers/number-parser.js\";\nexport { ObjectParser } from \"./src/parsers/object-parser.js\";\nexport { OrParsers } from \"./src/parsers/or-parser.js\";\nexport { ShapeParser } from \"./src/parsers/shape-parser.js\";\nexport { StringParser } from \"./src/parsers/string-parser.js\";\nexport { saferStringify } from \"./src/utils.js\";\nexport { NamedParser } from \"./src/parsers/named.js\";\nexport { ArrayOfParser } from \"./src/parsers/array-of-parser.js\";\nexport { LiteralsParser } from \"./src/parsers/literal-parser.js\";\nexport { ConcatParsers } from \"./src/parsers/concat-parser.js\";\nexport { MappedAParser } from \"./src/parsers/mapped-parser.js\";\nexport default matches;\n"],
  "mappings": "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",
  "names": ["isPartial", "parser", "recursive", "deferred"]
}
